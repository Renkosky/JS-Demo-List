<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    /**
     * 冒泡排序，复杂度O(n^2) 稳定算法
     * 比较前后两个数大小，如果前一个更大则互换位置
     **/
    function bubbleSort(arr) {
      let len = arr.length
      for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
          if (arr[j] > arr[j + 1]) {
            let temp = arr[j]
            arr[j + 1] = temp
            arr[j] = arr[j + 1]
          }
        }
      }
      return arr
    }
    /**
     * 选择排序 不稳定 复杂度：O(n^2)
     * 初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；
     * 然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
     **/

    function selectionSort(arr) {
      var len = arr.length;
      var minIndex, temp;
      for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
          if (arr[j] < arr[minIndex]) {     // 寻找最小的数
            minIndex = j;                 // 将最小数的索引保存
          }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
      }
      return arr;
    }

    // 分类 ------------- 内部比较排序
    // 数据结构 ---------- 数组
    // 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
    // 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
    // 平均时间复杂度 ---- O(n^2)
    // 所需辅助空间 ------ O(1)
    // 稳定性 ------------ 稳定
    //插入排序时首先把第一个元素当作已经排序，取出下一个元素
    //在已经排序的元素中从后向前扫描，如果该元素大于一排序中的元素，则插入到它的后面

    function name(arr) {
      for (var i = 1; i < arr.length; i++)         // 类似抓扑克牌排序
      {
        var get = A[i];                 // 右手抓到一张扑克牌
        var j = i - 1;                  // 拿在左手上的牌总是排序好的
        while (j >= 0 && A[j] > get)    // 将抓到的牌与手牌从右向左进行比较
        {
          A[j + 1] = A[j];            // 如果该手牌比抓到的牌大，就将其右移
          j--;
        }
        A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)
      }
    }
    /**
     * 希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。
     * 希尔排序是基于插入排序的以下两点性质而提出改进方法的：
     * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
     * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位　*希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。
     * 这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，
     * 算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。　
     * 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），
     * 可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。
     **/
    function ShellSort(arr) {
      var n = arr.length
      var h = 0;
      while (h <= n)                          // 生成初始增量
      {
        h = 3 * h + 1;
      }
      while (h >= 1) {
        for (var i = h; i < n; i++) {
          var j = i - h;
          var get = arr[i];
          while (j >= 0 && arr[j] > get) {
            arr[j + h] = arr[j];
            j = j - h;
          }
          arr[j + h] = get;
        }
        h = (h - 1) / 3;                    // 递减增量
      }
    }
    function shellSort2(arr) {
      var len = arr.length,
        temp,
        gap = 1;
      while (gap < len / 3) {          //动态定义间隔序列
        gap = gap * 3 + 1;
      }
      for (gap; gap > 0; gap = Math.floor(gap / 3)) {
        for (var i = gap; i < len; i++) {
          temp = arr[i];
          for (var j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
            arr[j + gap] = arr[j];
          }
          arr[j + gap] = temp;
        }
      }
      return arr;
    }
    ShellSort([5, 2, 9, 4, 7, 6, 1, 3, 8])
  </script>
</body>

</html>