//test()  :在字符串中查找符合正则的内容，若查找到返回true,反之返回false.
//search() ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置），
//如果搜索失败就返回 -1
//match() 在字符串中搜索复合规则的内容， 搜索成功就返回内容， 格式为数组， 失败就返回null。

/**用法： 字符串.match(正则)
 *量词： + 至少出现一次 匹配不确定的次数（ 匹配就是搜索查找的意思）
 *全局匹配： g—— global（ 正则中默认， 只要搜索到复合规则的内容就会结束搜索）
 */
var str = 'haj123sdk54hask33dkhalsd879'
var reg = /\d+/g //匹配多个数字，全局匹配
console.log(str.match(reg))

// i修饰符忽略大小写
/**
 * replace(): 查找符合正则的字符串， 就替换成对应的字符串。 返回替换后的内容。
 * 用法： 字符串.replace(正则, 新的字符串 / 回调函数)（ 在回调函数中， 第一个参数指的是每次匹配成功的字符）
 *
 * |: 或的意思。
 */

var str = '我爱北京天安门，天安门上太阳升。'
var reg = /北京|天安门/g
str.replace(reg, function(str) {
  var result = ''
  for (let i = 0; i < str.length; i++) {
    result += '*'
  }
  return result
})
//()：，小括号，叫做分组符。就相当于数学里面的括号。
var str = '2013-6-7'
var rel = /\d-+/g //3-,6-
var rel2 = /(\d-)+/g //3-6-
var rel3 = /(\d+)(-)/g

str = str.replace(re, function($0, $1, $2) {
  //replace()中如果有子项，
  //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,
  // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d   2013, 6)
  //第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )
  return $1 + '.' //分别返回2013.   6.
})
